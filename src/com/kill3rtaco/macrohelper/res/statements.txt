WAIT(time)=Waits for the specified number of seconds, alternatively to specify a wait time in milliseconds, add "ms" to the time, for example WAIT(500ms) will wait for half a second.
FOV(fov,-time)=Sets the current FOV to fov, for example FOV(90). If you specify the time parameter the FOV will interpolate in the specified time (seconds).
GAMMA(pct,-time)=Sets the gamma (brightness) to the specified value (percent). If you specify the time option, the gamma will interpolate to the new value.
SENSITIVITY(pct,-time)=Sets the mouse sensitivity to the specified value (percent). If you specify the time option, the gamma will interpolate to the new value.
VOLUME(pct,-time)=Sets the sound volume to the specified value (percent). If you specify the time option, the gamma will interpolate to the new value.
MUSIC(pct,-time)=Sets the music volume to the specified value (percent). If you specify the time option, the gamma will interpolate to the new value.
FOG()=Takes no parameters and toggles the render distance.
GUI(screen)=Displays the specified GUI. The available values for "screen" are:\n\n\tchat\n\tmenu\n\tinventory\n\toptions\n\tvideo\n\tcontrols\n\tmacrobind\n\tmacroconfig
CONFIG(name)=Selects the specified config, specify "" to select the default config or enter a config name.
IMPORT(name)=Imports the specified config. The config will be overlaid on the current config, replacing only keys which are defined in the imported configuration. For example, if you are using a server config and have a worldedit config which defines only the numpad keys, you can IMPORT the worldedit config and only the numpad keys will be altered, the rest of the keys will remain using the active config. Calling IMPORT again with the same config will UNIMPORT the config (it is a toggle).
UNIMPORT()=Removes the active overlaid config if one is active.
DISCONNECT()=Disconnect from the current server, or quit to title if in single player.
KEY(key)=Simulate pressing the specified key once. The available values for "key" are:\n\n\tinventory\n\tdrop\n\tchat\n\tattack\n\tuse\n\tpick\n\nIf you want to activate a keybind for a different key, you may also use the LWJGL key code for the key bind to activate. To pump actual simulated keypresses into the keyboard buffer, use the TYPE and PRESS commands instead.
KEYDOWN(key)=Simulates a key down event for the specified key, use the KEYUP command to release the key. Available values for "key" are:\n\n\tforward\n\tback\n\tleft\n\tright\n\tjump\n\tsneak\n\t<keycode>  Insert the LWJGL key code to send a key event\n\nNOTE: If you wish to send a KEYDOWN followed by a KEYUP you *must* insert a WAIT between the two commands, otherwise Minecraft will not register the key event. For example, use the following script to simulate pressing the forward key for half a second:\n\n\tKEYDOWN(forward);WAIT(500ms);KEYUP(forward)
KEYUP(key)=Simulates a key up event, the available keys are the same as for  the KEYDOWN command.
TOGGLEKEY(key)=Toggles the key/up down state of the specified key. The available keys are the same as for the KEYUP and KEYDOWN commands. For example to create a simple auto-walk macro, use the following script:\n\ntTOGGLEKEY(forward)
ECHO(message)=Echos the specified text into the chat buffer, this is useful in long scripts to avoid having to include multiple }$$ $${ symbols.
LOG(message)=Echos the specified text to the local chat log. Useful to track running macros. You can include colour codes in the format &0
INVENTORYDOWN(count)=Scrolls the specified number of slots through the inventory
INVENTORYUP(count)=Scrolls the specified number of slots through the inventory
PICK(itemid)=If an item with the specified ID exists on your hotbar, the item is selected
SLOT(number)=Select a slot on the hot bar (valid numbers are 1 through 9)
SPRINT()=Begin sprinting (if the player would normally be able to sprint)
UNSPRINT()=Stop sprinting
STOP(keyname)=Terminates active (latent) macros with the specified key name. Use without parameters to stop latent functions on the CURRENT key. Alternatively specify "all" to stop ALL macros, or the name of a macro task started with EXEC (see below).
TYPE(string)=Pumps the individual keys specified in <string> into the keyboard buffer as if they were typed by the user. This is useful for supplying key events to mod GUIs or other input fields which are not normally scriptable. This function only accepts printable characters, to pump other keys into the buffer use the PRESS command instead.
PRESS(key)=Pumps a key down followed by a key up event into the keyboard buffer for the specified key, simulating the key being pressed. This should work for mods which sample the keyboard directly rather than using the KeyBind mechanism in Minecraft. Key should be a valid LWJGL key name, eg.\n\n\tPRESS(RETURN);
PLACESIGN(line1,line2,line3,line4,showgui)=If you have a sign on your hot bar and are aiming at a block within placement distance, the sign will be placed at the 4 lines of text will be set to the text specified. If the fifth option is omitted or false, the sign will be placed immediately. If the fifth option is 1 or true, the sign gui will be displayed with the lines of text pre-populated. eg.\n\n\tPLACESIGN("[Buy]","64","Stone","$5");\n\nFor placing signshop signs for bukkit essentials.\n\n\tPLACESIGN("[Buy]","64","Stone","$5",true);\n\nWill pre-populate the specified text and allow the sign to be edited. Specified name. If an exact match cannot be found, the first texture pack which matches the specified name will be selected, this means you can select texture packs by only entering a key part of the name like "pangea", "space", "medieval" or "doku" for example. To select the default texture pack, simply execute the command with no parameters: TEXTUREPACK()
SET(flag)=Sets the specified flag to true (on) for this macro. This is used with conditionals (see below). You can use any name for flags thatyou wish, but bear in mind that all flags are internally converted to lower case and must be referenced in lower case in conditional statements.
UNSET(flag)=Like the SET command, but sets the specified flag to false (off) for this macro.
TOGGLE(flag)=Like SET and UNSET, but changes the state of the flag to the opposite of its current value. If the flag is true (on) it will be set to false (off), and vice versa.
INC(counter)=Increments a counter by 1, or alternatively specify an amount to increment by, eg. INC(#mycounter, 3)
DEC(counter)=Decrements a counter by 1, or alternatively specify an amount to decrement by, eg. DEC(#mycounter, 3)
EXEC(filename)=Executes a file as a script, the script executes as a separatetask, allowing you to "spin off" a separate macro which runs concurrently with other macros.\n\nUse EXEC(filename,taskname) if you wish to be able to stop the task at a later time using STOP, specifying the taskname allows you to stop the task by specifying the name:\n\n\tEXEC("script.txt","mytask");\n\n\t...\n\n\tSTOP("mytask");\n\nFollowing parameters which will be passed to the target script as both numbered parameters and numbered variables:\n\n\tEXEC("script.txt","mytask","param1","anotherparam");\n\nWill allow you to use the specified parameters in your target script as $$[1] $$[2] $$[3] and so on as parameters or alternatively var1, var2, var3 as variables:\n\n\tIF(var1 = "param1");\n\t\t// do something\n\tELSE;\n\t\tECHO("Param 2 is $$[2]");\n\tENDIF;\nThe difference between parameters and variables is that parametersare replaced into the script *before* it is executed whereas variables are only checked when the script is executed, this allows you to use a parameter like this:\n\n\t$$<$$[1]>\n\nto include a file specified at invoke-time. Using variables for other values is "safer" because the variable value is never inserted into the script and therefore cannot corrupt the macro if invalid values are passed in.
LOOK(dir,speed)=Sets the player's look direction to the specified direction, this can be NORTH, SOUTH, EAST, WEST or NEAR. The NEAR option snaps the view to the nearest cardinal direction to the current view direction. You can also specify the speed to interpolate to the  specified direction.\n\nThe LOOK command also supports the following variations:\n\n\tLOOK(yaw)\n\tLOOK(yaw,pitch)\n\tLOOK(yaw,pitch,speed)\n\nWhere yaw and pitch are specified as either absolute values (eg. 180 to face south, or relative values, eg. +45 to turn 45 degrees
LOOKS(dir,speed)=This is identical to LOOK, but adds a smooth ramp to the interpolation making it more cinematic.